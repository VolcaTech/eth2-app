pragma solidity 0.4.23;
import './SafeMath.sol';
import './Stoppable.sol';

/**
 * @title VerifiedProxy
 * @dev Contract allows to send ether through verifier (owner of contract).
 * 
 * Only verifier can initiate withdrawal to recipient's address. 
 * Verifier cannot choose recipient's address without 
 * verification private key generated by sender. 
 * 
 * Sender is responsible to provide verification private key
 * to recipient off-chain.
 * 
 * Recepient signs address to receive with verification private key and 
 * provides signed address to verification server. 
 * (See VerifyTransferSignature method for details.)
 * 
 * Verifier verifies off-chain the recipient in accordance with verification 
 * conditions (e.g., phone ownership via SMS authentication) and initiates
 * withdrawal to the address provided by recipient.
 * (See withdraw method for details.)
 * 
 * Verifier charges commission for it's services.
 * 
 * Sender is able to cancel transfer if it's not already cancelled or withdrawn
 * by recipient.
 * (See cancelTransfer method for details.)
 */
contract VerifiedProxy is Stoppable, SafeMath {

  // Status codes
  enum Statuses {
    EMPTY,
    ACTIVE, // awaiting withdrawal
    COMPLETED, // recepient have withdrawn the transfer
    CANCELLED  // sender has cancelled the transfer
  }

  // fixed amount of wei accrued to verifier with each transfer
  uint public commissionFee;

  // verifier can withdraw this amount from smart-contract
  uint public commissionToWithdraw; // in wei

  // gas cost to withdraw transfer
  uint private WITHDRAW_GAS_COST = 80000;

  /*
   * EVENTS
   */
  event LogDeposit(
		   address indexed from,
		   address indexed transferId,
		   uint amount,
		      uint commission
		   );

  event LogCancel(
		  address indexed from,
		  address indexed transferId,
		    uint amount
		  );

  event LogWithdraw(
		    address indexed transferId,
		    address indexed sender,
		    address indexed recipient,
		        uint amount
		    );

  event LogWithdrawCommission(uint commissionAmount);

  event LogChangeFixedCommissionFee(
				    uint oldCommissionFee,
				                uint newCommissionFee
				    );

  struct Transfer {
    uint8 status; // 0 - active, 1 - completed, 2 - cancelled;
    address from;
    uint amount; // in wei
  }

  // Mappings of TransferId => Transfer Struct
  mapping (address => Transfer) transferDct;


  /**
   * @dev Contructor that sets msg.sender as owner (verifier) in Ownable
   * and sets verifier's fixed commission fee.
   * @param _commissionFee uint Verifier's fixed commission for each transfer
   */
  constructor(uint _commissionFee) public {
    commissionFee = _commissionFee;
  }


  /**
   * @dev Deposit ether to smart-contract and create transfer.
   * Verification public key is assigned to transfer. 
   * Recipient should sign his address with private key 
   * for verification public key.
   * 
   * @param _verPubKey address Verifification public key.
   * @return True if success.
   */
  function deposit(address _verPubKey)
                            public
                            whenNotPaused
                            whenNotStopped
                            payable
    returns(bool)
  {
    // can not override old transfer
    require(transferDct[_verPubKey].status == 0);

    //uint transferGasCommission = safeMul(tx.gasprice, WITHDRAW_GAS_COST);
    //uint transferCommission = safeAdd(commissionFee,transferGasCommission);
    require(msg.value > commissionFee);

    // saving transfer details
    transferDct[_verPubKey] = Transfer(
				       uint8(Statuses.ACTIVE),
				       msg.sender,
				       safeSub(msg.value, commissionFee)//amount = msg.value - comission
				       );

    // verification server commission accrued
    commissionToWithdraw = safeAdd(commissionToWithdraw, commissionFee);

    // log deposit event
    emit LogDeposit(msg.sender, _verPubKey, msg.value, commissionFee);
    return true;
  }

  /**
   * @dev Change verifier's fixed commission fee.
   * Only owner can change commision fee.
   * 
   * @param _newCommissionFee uint New verifier's fixed commission
   * @return True if success.
   */
  function changeFixedCommissionFee(uint _newCommissionFee)
                          public
                          whenNotPaused
                          whenNotStopped
                          onlyOwner
    returns(bool success)
  {
    uint oldCommissionFee = commissionFee;
    commissionFee = _newCommissionFee;
    emit LogChangeFixedCommissionFee(oldCommissionFee, commissionFee);
    return true;
  }

  /**
   * @dev Transfer accrued commission to verifier's address.
   * @return True if success.
   */
  function withdrawCommission()
                        public
                        whenNotPaused
    returns(bool success)
  {
    uint commissionToTransfer = commissionToWithdraw;
    commissionToWithdraw = 0;
    owner.transfer(commissionToTransfer); // owner is verifier

    emit LogWithdrawCommission(commissionToTransfer);
    return true;
  }

  /**
   * @dev Get transfer details.
   * @param _transferId address Unique transfer id.
   * @return Transfer details (id, status, sender, amount)
   */
  function getTransfer(address _transferId)
            public
            constant
    returns (
	     address id,
	     uint status, // 0 - active, 1 - completed, 2 - cancelled;
	     address from, // transfer sender
	     uint amount) // in wei
  {
    Transfer memory transfer = transferDct[_transferId];
    return (
	    _transferId,
	    transfer.status,
	    transfer.from,
	            transfer.amount
	    );
  }


  /**
   * @dev Cancel transfer and get sent ether back. Only transfer sender can
   * cancel transfer.
   * @param _transferId address Unique transfer id.
   * @return True if success.
   */
  function cancelTransfer(address _transferId) public returns (bool success) {
    Transfer storage transferOrder = transferDct[_transferId];

    // only sender can cancel transfer;
    require(msg.sender == transferOrder.from);

    // only active transfers can be cancelled;
    require(transferOrder.status == uint8(Statuses.ACTIVE));

    // set transfer's status to cancelled.
    transferOrder.status = uint8(Statuses.CANCELLED);

    // transfer ether back to sender
    transferOrder.from.transfer(transferOrder.amount);

    // log cancel event
    emit LogCancel(msg.sender, _transferId, transferOrder.amount);
    return true;
  }

  /**
   * @dev Verify that address is signed with correct verification private key.
   * @param _verPubKey address Verification public key.
   * @param _recipient address Signed address.
   * @param _v ECDSA signature parameter v.
   * @param _r ECDSA signature parameters r.
   * @param _s ECDSA signature parameters s.
   * @return True if signature is correct.
   */
  function verifySignature(
			   address _verPubKey,
			   address _recipient,
			   uint8 _v,
			   bytes32 _r,
			   bytes32 _s)
    private pure returns(bool success)
  {
    bytes32 prefixedHash = keccak256("\x19Ethereum Signed Message:\n32", _recipient);
    address retAddr = ecrecover(prefixedHash, _v, _r, _s);
    return retAddr == _verPubKey;
  }

  /**
   * @dev Verify that address is signed with correct private key for
   * verification public key assigned to transfer.
   * @param _transferId bytes32 Transfer Id.
   * @param _recipient address Signed address.
   * @param _v ECDSA signature parameter v.
   * @param _r ECDSA signature parameters r.
   * @param _s ECDSA signature parameters s.
   * @return True if signature is correct.
   */
  function verifyTransferSignature(
				   address _transferId,
				   address _recipient,
				   uint8 _v,
				   bytes32 _r,
				   bytes32 _s)
    public pure returns(bool success)
  {
    return (verifySignature(_transferId,
			    _recipient, _v, _r, _s));
  }

  /**
   * @dev Withdraw transfer to recipient's address if it is correctly signed
   * with private key for verification public key assigned to transfer.
   * 
   * @param _transferId bytes32 Transfer Id.
   * @param _recipient address Signed address.
   * @param _v ECDSA signature parameter v.
   * @param _r ECDSA signature parameters r.
   * @param _s ECDSA signature parameters s.
   * @return True if success.
   */
  function withdraw(
		    address _transferId,
		    address _recipient,
		    uint8 _v,
		    bytes32 _r,
		    bytes32 _s)
    public
    onlyOwner // only through verifier can withdraw transfer;
            whenNotPaused
            whenNotStopped
    returns (bool success)
  {
    Transfer storage transferOrder = transferDct[_transferId];

    // only active transfers can be withdrawn;
    require(transferOrder.status == uint8(Statuses.ACTIVE));

    // verifying signature
    require(verifySignature(_transferId,
			    _recipient, _v, _r, _s ));

    // set transfer's status to completed.
    transferOrder.status = uint8(Statuses.COMPLETED);

    // transfer ether to recipient's address
    _recipient.transfer(transferOrder.amount);

    // log withdraw event
    emit LogWithdraw(_transferId, transferOrder.from, _recipient, transferOrder.amount);
    return true;
  }


  // fallback function - do not receive ether by default
  function() public payable {
    revert();
  }
}
